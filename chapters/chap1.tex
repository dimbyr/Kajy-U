\chapter{Structures de donn\'ees fondamentales}
%\minitoc
\section{Variables}
Les variables constituent l'un des concepts les plus fondamentaux en programmation. En langage C, une variable est un espace de stockage nommé qui peut contenir une valeur modifiable. Les variables sont utilisées pour stocker des données telles que des nombres, des caractères et des adresses mémoire.

\subsection{Déclaration de variables}

En language C, on d\'eclare une variable en pr\'ec\'edant son nom le type de donn\'ee qu'elle contient. 

\begin{lstlisting}
	int age; // Declaration d'une variable de type entier appelee "age"
	float prix; // Declaration d'une variable de type flottant appelee "prix"
	char lettre; // Declaration d'une variable de type caractere appelee "lettre"
\end{lstlisting}

\subsection{Initialisation des variables}

Les variables peuvent être initialisées lors de leur déclaration en leur attribuant une valeur initiale. Par exemple :

\begin{lstlisting}
	int nombre = 10; // Declaration et initialisation d'une variable de type entier avec la valeur 10
	float pi = 3.14; // Declaration et initialisation d'une variable de type flottant avec la valeur 3.14
	char grade = 'A'; // Declaration et initialisation d'une variable de type caractere avec la valeur 'A'
\end{lstlisting}

\subsection{Utilisation des variables}

Une fois déclarées et éventuellement initialisées, les variables peuvent être utilisées dans le programme pour stocker et manipuler des données. Par exemple :

\begin{lstlisting}
	#include <stdio.h>;
	int x = 5;
	int y = 10;
	int somme = x + y; // Addition des valeurs des variables x et y
	printf("La somme de %d et %d est %d\n", x, y, somme); // Affichage du resultat
\end{lstlisting}

\subsection{Portée des variables}

La portée d'une variable en C détermine où elle peut être utilisée dans le programme. Les variables peuvent être locales à une fonction, auquel cas elles ne sont accessibles que dans cette fonction, ou elles peuvent être globales, auquel cas elles sont accessibles dans tout le programme.

\begin{lstlisting}
	#include <stdio.h>;
	
	int globalVar = 100; // Variable globale
	
	void exampleFunction() {
		int localVar = 50; // Variable locale a la fonction exampleFunction
		printf("La variable globale est %d\n", globalVar); // Acces a la variable globale
		printf("La variable locale est %d\n", localVar); // Acces a la variable locale
	}
	
	int main() {
		printf("La variable globale est %d\n", globalVar); // Acces a la variable globale
		// printf("La variable locale est %d\n", localVar); // Cela generera une erreur car localVar est locale a exampleFunction
		exampleFunction();
		return 0;
	}
\end{lstlisting}

Les variables sont un element essentiel en langage C et constituent la base de la manipulation des donnees dans les programmes. Il est crucial de comprendre leur declaration, leur initialisation, leur utilisation et leur portee pour ecrire des programmes efficaces et fonctionnels.


\section{Pointeurs}

Les pointeurs sont un concept essentiel en langage C. Un \emph{pointeur} est une variable qui contient l'adresse mémoire d'une autre variable. En d'autres termes, un pointeur pointe vers l'emplacement en mémoire où une valeur est stockée.

\subsection{Déclaration de pointeurs}

En langage C, un pointeur est déclaré en précédant le nom de la variable avec l'opérateur *, qui indique que la variable est un pointeur. Voici un exemple de déclaration de pointeur :

\begin{lstlisting}
	int *ptr; // Declaration d'un pointeur vers un entier
	float *ptr_float; // Declaration d'un pointeur vers un flottant
	char *ptr_char; // Declaration d'un pointeur vers un caractere
\end{lstlisting}

\subsection{Initialisation de pointeurs}

Les pointeurs peuvent être initialisés avec l'adresse mémoire d'une variable existante à l'aide de l'opérateur d'adresse \&. Voici un exemple d'initialisation de pointeur :

\begin{lstlisting}
	int var = 10; // Declaration et initialisation d'une variable
	int *ptr; // Declaration d'un pointeur
	ptr = &var; // Initialisation du pointeur avec l'adresse de la variable var
\end{lstlisting}

\subsection{Utilisation de pointeurs}

Une fois qu'un pointeur est initialisé, il peut être utilisé pour accéder à la valeur à laquelle il pointe ou pour modifier cette valeur. Voici quelques exemples :

\begin{lstlisting}
	#include <stdio.h>;
	int var = 10; // Declaration et initialisation d'une variable
	int *ptr; // Declaration d'un pointeur
	ptr = &var; // Initialisation du pointeur avec l'adresse de la variable var
	printf("La valeur de var est %d\n", var); // Affichage de la valeur de var
	printf("L'adresse de var est %p\n", &var); // Affichage de l'adresse de var
	printf("La valeur pointee par le pointeur est %d\n", *ptr); // Affichage de la valeur pointee par le pointeur
	*ptr = 20; // Modification de la valeur pointee par le pointeur
	printf("La nouvelle valeur de var est %d\n", var); // Affichage de la nouvelle valeur de var
\end{lstlisting}

Les pointeurs sont un concept puissant en langage C, mais ils nécessitent une manipulation prudente pour éviter les erreurs de segmentation et les fuites de mémoire.

\subsection{Double pointeurs}

Les double pointeurs (ou pointeurs vers des pointeurs) contiennent l'adresse mémoire d'un autre pointeur. Ils sont utiles pour passer des pointeurs par référence à des fonctions, pour des structures de données complexes comme des tableaux de tableaux, ou pour manipuler des listes chaînées.

Voici un exemple de déclaration et d'utilisation d'un double pointeur :

\begin{lstlisting}
	int a = 5;
	int *ptr = &a; // Pointeur vers int
	int **double_ptr = &ptr; // Double pointeur vers pointeur int
	
	printf("La valeur de a est %d\\n", a); // Affichage de la valeur de a
	printf("La valeur pointe par ptr est %d\\n", *ptr); // Affichage de la valeur pointee par ptr
	printf("La valeur pointee par double_ptr est %d\\n", **double_ptr); // Affichage de la valeur pointee par double_ptr
\end{lstlisting}

Les double pointeurs sont également utilisés pour retourner des pointeurs depuis des fonctions ou pour allouer dynamiquement de la mémoire pour des structures comme des tableaux 2D.

\subsection{Utilisation avancée des pointeurs}

Les pointeurs permettent des opérations avancées comme l'arithmétique des pointeurs, où vous pouvez ajouter ou soustraire des valeurs pour déplacer le pointeur en mémoire. Voici un exemple :

\begin{lstlisting}
	int tableau[5] = {1, 2, 3, 4, 5};
	int *ptr = tableau;
	
	printf("Premier element: %d\\n", *ptr); // Affichage du premier element
	ptr++; // Deplacement du pointeur vers le prochain element
	printf("Deuxieme element: %d\\n", *ptr); // Affichage du deuxieme element
\end{lstlisting}

Soyez prudent avec l'arithmétique des pointeurs, car elle peut conduire à des erreurs de segmentation si vous sortez des limites de la mémoire allouée.

\subsection{Pointeurs et mémoire dynamique}

Les pointeurs sont essentiels pour la gestion de la mémoire dynamique en langage C. Avec des fonctions comme `malloc` et `free`, vous pouvez allouer et libérer de la mémoire au moment de l'exécution. Voici un exemple :

\begin{lstlisting}
	int *array = (int *)malloc(10 * sizeof(int)); // Allouer de la memoire pour 10 entiers
	if (array == NULL) {
		printf("Echec de l'allocation de memoire!\\n");
		return 1;
	}
	
	for (int i = 0; i < 10; i++) {
		array[i] = i * 2; // Initialisation de la memoire allouee
	}
	
	free(array); // Liberer la memoire
\end{lstlisting}

La gestion de la mémoire est cruciale lors de l'utilisation des pointeurs. Assurez-vous de toujours libérer la mémoire allouée pour éviter les fuites de mémoire.


\section{Types de données}

Les types de données en langage C déterminent la nature des valeurs qu'une variable peut contenir. Le langage C prend en charge plusieurs types de données de base, ainsi que des types de données dérivés tels que les tableaux et les structures.

\subsection{Types de données de base}

Les types de données de base définissent les valeurs simples que peuvent contenir les variables en langage C. Voici quelques-uns des types de données de base les plus couramment utilisés, avec leurs tailles habituelles:

\begin{enumerate}[label=\alph*)]
	\item \textbf{int} : Pour les entiers signés (généralement 4 octets).
	\item \textbf{float} : Pour les nombres à virgule flottante (généralement 4 octets).
	\item \textbf{double} : Pour les nombres à virgule flottante double précision (généralement 8 octets).
	\item \textbf{char} : Pour les caractères ASCII (généralement 1 octet).
\end{enumerate}

Voici des exemples de déclaration de variables pour ces types de données:

\begin{lstlisting}
	int age = 30; // Declaration d'une variable de type entier
	float poids = 75.5; // Declaration d'une variable de type flottant
	double prix = 99.99; // Declaration d'une variable de type double
	char grade = 'A'; // Declaration d'une variable de type caractere
\end{lstlisting}

\subsection{Types de données dérivés}

Outre les types de données de base, le langage C offre la possibilité de créer des types de données dérivés, comme les tableaux, les structures, les unions et les énumérations.

\begin{enumerate}[label=\alph*)]
	\item \textbf{Tableaux} :
	
	Un tableau est une collection ordonnée d'éléments du même type. Les éléments d'un tableau sont accessibles via un index numérique. Voici un exemple de déclaration d'un tableau et d'opérations de base:
	
	\begin{lstlisting}
		int tableau[5]; // Declaration d'un tableau de taille 5
		tableau[0] = 10; // Attribuer la valeur 10 au premier element
		tableau[1] = 20; // Attribuer la valeur 20 au deuxieme element
	\end{lstlisting}
	
	\item \textbf{Structures} :
	
	Les structures permettent de regrouper des variables de types différents. Elles permettent de définir des types de données personnalisés. Voici un exemple d'utilisation des structures:
	
	\begin{lstlisting}
		#include <stdio.h>;
		#include <string.h>;
		
		struct Personne {
			char nom[50];
			int age;
			float taille;
		};
		
		struct Personne p1; // Declaration d'une structure de type Personne
		strcpy(p1.nom, "John Doe"); // Attribution d'une valeur au champ nom
		p1.age = 30; // Attribution d'une valeur au champ age
		p1.taille = 1.75; // Attribution d'une valeur au champ taille
	\end{lstlisting}
	
	\item \textbf{Unions} :
	
	Les unions permettent de partager la même zone mémoire entre différents types de données. Voici un exemple de déclaration d'une union:
	
	\begin{lstlisting}
		union Data {
			int entier;
			float flottant;
			char caractere;
		};
		
		union Data d;
		d.entier = 10; // Utilisation de l'union avec un entier
		d.flottant = 5.5; // Utilisation avec un flottant (ecrase l'entier)
	\end{lstlisting}
	
	\item \textbf{Énumérations} :
	
	Les énumérations permettent de définir un ensemble de valeurs nommées. Elles sont utiles pour créer des listes de constantes. Voici un exemple d'utilisation des énumérations:
	
	\begin{lstlisting}
		enum Jour {LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE};
		
		enum Jour aujourdhui = MERCREDI; // Declaration d'une enumeration et initialisation
	\end{lstlisting}
\end{enumerate}

\subsection{Typedef}

Le mot-clé \emph{typedef} permet de créer des alias pour des types de données existants. Cela peut simplifier des déclarations complexes, rendre le code plus lisible, et améliorer l'abstraction des types. `typedef` est couramment utilisé pour simplifier des déclarations de pointeurs, de structures, d'unions, et de fonctions.

\subsubsection*{Alias pour des types de base}

Voici un exemple d'utilisation de `typedef` pour créer un alias pour un type de base :

\begin{lstlisting}
	typedef int Entier; // Creation d'un alias pour int
	Entier age = 30; // Utilisation du typedef pour creer un alias
\end{lstlisting}

Cet exemple montre comment `typedef` peut simplifier des déclarations. Utiliser des alias descriptifs peut rendre le code plus lisible et compréhensible, en particulier lorsque les types de base ont des applications spécifiques.

\subsubsection*{Utilisation avec des pointeurs}

Les pointeurs en C peuvent être complexes à déclarer, surtout pour les pointeurs de fonctions ou les structures dérivées. `typedef` simplifie les déclarations de pointeurs en créant des alias :

\begin{lstlisting}
	typedef int* PointeurEntier; // Alias pour un pointeur vers int
	PointeurEntier ptr = NULL; // Declaration d'un pointeur vers int
\end{lstlisting}

Vous pouvez également utiliser `typedef` pour simplifier des déclarations de pointeurs de fonctions, rendant le code plus lisible :

\begin{lstlisting}
	typedef int (*Fonction)(int, int); // Alias pour un pointeur vers une fonction
\end{lstlisting}

\subsubsection*{Utilisation avec des structures}

`typedef` est largement utilisé pour simplifier les déclarations de structures complexes. Cela facilite l'utilisation de structures pour regrouper des variables de types différents :

\begin{lstlisting}
	typedef struct {
		char nom[50];
		int age;
		float taille;
	} Personne;
	
	Personne p1; // Utilisation du typedef pour nommer une structure
\end{lstlisting}

Avec `typedef`, les déclarations de structures deviennent plus concises et lisibles, ce qui peut simplifier le code et faciliter les modifications futures.

\subsubsection*{Utilisation avec des unions}

Les unions permettent de partager la même zone mémoire entre différents types de données. `typedef` peut être utilisé pour nommer des unions, ce qui simplifie l'utilisation des structures complexes :

\begin{lstlisting}
	typedef union {
		int entier;
		float flottant;
		char caractere;
	} Donnees;
	
	Donnees d; // Utilisation du typedef pour nommer une union
\end{lstlisting}

\subsubsection*{Utilisation avec des énumérations}

Les énumérations permettent de définir des ensembles de valeurs nommées. `typedef` facilite la déclaration et l'utilisation des énumérations :

\begin{lstlisting}
	typedef enum {LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE} Jour;
	
	Jour aujourd'hui = MERCREDI; // Utilisation de l'enumeration avec typedef
\end{lstlisting}

\subsubsection*{Avantages de `typedef`}

`typedef` offre plusieurs avantages pour le code C, notamment :

- \textbf{Simplification des déclarations complexes} : `typedef` permet de rendre le code plus concis en créant des alias pour des déclarations compliquées.
- \textbf{Lisibilité accrue} : Les alias créés avec `typedef` rendent le code plus facile à lire et à comprendre.
- \textbf{Abstraction des types} : `typedef` permet de créer des abstractions pour des types de données, ce qui facilite les modifications futures.
- \textbf{Réutilisation du code} : Les alias créés avec `typedef` peuvent être réutilisés dans différents contextes, ce qui améliore la maintenabilité du code.

Dans l'ensemble, `typedef` est un outil puissant en langage C qui permet de simplifier les déclarations complexes, de rendre le code plus lisible, et de faciliter la création de types de données personnalisés. Que ce soit pour des pointeurs, des structures, des unions, ou des fonctions, `typedef` est un outil précieux pour les développeurs C.


\section{Exercices}

\textbf{Types de données:}

\begin{enumerate}
	\item Écrivez un programme C pour déclarer une variable de chaque type de données de base et initialisez-les avec des valeurs.
	\item Déclarez un tableau d'entiers de taille 10 et initialisez-le avec des valeurs de votre choix. Affichez ensuite ces valeurs à l'écran.
	\item Créez une structure \texttt{Personne} avec des champs pour le nom, l'âge et la taille. Déclarez une variable de type \texttt{Personne} et initialisez-la avec des valeurs fictives. Affichez ensuite ces valeurs à l'écran.
	\item Écrivez une fonction en C pour inverser une chaîne de caractères donnée.
	\item Écrivez une fonction en C pour trier un tableau d'entiers en utilisant l'algorithme de tri à bulles.
%\end{enumerate}

\textbf{Types de données de base:}

%\begin{enumerate}
	\item Écrivez un programme C pour convertir un nombre entier en binaire.
	\item Écrivez une fonction en C pour calculer la somme des chiffres d'un nombre entier.
	\item Déclarez une variable de type \texttt{char} et utilisez-la pour stocker une lettre majuscule. Ensuite, utilisez une opération pour convertir cette lettre en minuscule.
	\item Écrivez un programme C pour vérifier si un nombre donné est premier ou non.
	\item Écrivez une fonction récursive en C pour calculer le factoriel d'un nombre entier.
%\end{enumerate}

\textbf{Types de données dérivés:}

%\begin{enumerate}
	\item Écrivez une fonction en C pour concaténer deux chaînes de caractères données.
	\item Déclarez un tableau de structures \texttt{Etudiant} avec des champs pour le nom, l'âge et la moyenne. Initialisez-le avec des valeurs fictives et affichez ensuite ces valeurs à l'écran.
	\item Écrivez une fonction en C pour ajouter un élément à une liste chaînée.
	\item Implémentez une file (queue) en utilisant des listes chaînées en C.
	\item Écrivez une fonction en C pour supprimer un élément d'un arbre binaire de recherche.
%\end{enumerate}

\textbf{Typedef}

%\begin{enumerate}
	 \item \textbf{Création d'un alias pour un type de base}
	
	Utilisez `typedef` pour créer un alias pour un type de données de base. Ensuite, déclarez une variable de ce type et affichez sa valeur.
	
	\begin{lstlisting}
		typedef ...
		... var = 25;
		
		printf("La valeur de var est %d\\n", var);
	\end{lstlisting}
	
	\item \textbf{Utilisation de typedef avec des pointeurs}
	
	Utilisez `typedef` pour créer un alias pour un pointeur vers un entier. Initialisez le pointeur avec l'adresse d'une variable entière et affichez la valeur à laquelle le pointeur fait référence.
	
	\begin{lstlisting}
		typedef ...
		int a = 10;
		... ptr = &a;
		
		printf("La valeur pointee par le pointeur est %d\\n", *ptr);
	\end{lstlisting}
	
	\item \textbf{Utilisation de typedef avec des structures}
	
	Utilisez `typedef` pour créer un alias pour une structure représentant une personne avec des champs comme le nom, l'âge, et la taille. Ensuite, déclarez une variable de ce type et attribuez des valeurs aux champs.
	
	\begin{lstlisting}
		typedef struct {
			char nom[50];
			int age;
			float taille;
		} ...;
		
		... p1;
		
		strcpy(p1.nom, "Alice");
		p1.age = 25;
		p1.taille = 1.65;
	\end{lstlisting}
	
	\item \textbf{Utilisation de typedef avec des énumérations}
	
	Utilisez `typedef` pour créer un alias pour une énumération représentant les jours de la semaine. Déclarez une variable de ce type et attribuez-lui un jour spécifique.
	
	\begin{lstlisting}
		typedef enum {
			LUNDI,
			MARDI,
			MERCREDI,
			...
		} ...;
		
		... aujourd'hui = MERCREDI;
	\end{lstlisting}
	
	\item \textbf{Utilisation de typedef avec des unions}
	
	Utilisez `typedef` pour créer un alias pour une union contenant un entier, un flottant, et un caractère. Déclarez une variable de ce type et attribuez des valeurs aux différents éléments de l'union.
	
	\begin{lstlisting}
		typedef union {
			int entier;
			float flottant;
			char caractere;
		} ...;
		
		... d;
		d.entier = 10;
		d.flottant = 5.5;
	\end{lstlisting}
\end{enumerate}
